[NEAT]
fitness_criterion     = max

# Threshold raggiungibile: 10K Ã¨ un ottimo score per Pac-Man
fitness_threshold     = 10000.0

# Popolazione bilanciata: 200 Ã¨ il sweet spot velocitÃ /diversitÃ 
pop_size              = 200

# Non resettare se tutte le specie si estinguono
reset_on_extinction   = False 
no_fitness_termination = False

[DefaultGenome]
single_structural_mutation = false
structural_mutation_surer = default

# === Input/Output ===
num_inputs              = 128
num_outputs             = 5

# ğŸ”¥ CAMBIAMENTO CRITICO: parti con neuroni nascosti
# Permette pattern complessi da subito invece di evolvere da zero
num_hidden              = 0

# === Attivazione ===
# ReLU funziona meglio in Reinforcement Learning rispetto a tanh
activation_default      = relu
activation_mutate_rate  = 0.1
activation_options      = relu tanh sigmoid

# === Aggregazione ===
aggregation_default     = sum
aggregation_mutate_rate = 0.0
aggregation_options     = sum

# === Bias ===
bias_init_mean          = 0.0
bias_init_stdev         = 1.0
bias_init_type          = gaussian
bias_max_value          = 30.0
bias_min_value          = -30.0
bias_mutate_power       = 0.5
bias_mutate_rate        = 0.8
bias_replace_rate       = 0.1

# === CompatibilitÃ  (Speciazione) ===
# Questi coefficienti determinano quando due genomi sono "diversi"
compatibility_disjoint_coefficient = 1.0
compatibility_weight_coefficient   = 0.5

# === Connessioni ===
# Bilanciate per crescita controllata della rete
conn_add_prob           = 0.4
conn_delete_prob        = 0.1

enabled_default         = True
enabled_mutate_rate     = 0.01
enabled_rate_to_true_add = 0.0
enabled_rate_to_false_add = 0.0

# === Struttura ===
# False = Recurrent Neural Network (permette memoria temporale)
feed_forward            = False

# Connessioni iniziali: 30% degli input connessi agli output
# PiÃ¹ alto = rete piÃ¹ complessa dall'inizio
initial_connection      = partial_direct 0.5

# === Nodi (Neuroni Nascosti) ===
# Permette alla rete di crescere in profonditÃ 
node_add_prob           = 0.25
node_delete_prob        = 0.1

# === Response ===
# Coefficiente di risposta dei neuroni (solitamente fisso a 1.0)
response_init_mean      = 1.0
response_init_stdev     = 0.0
response_init_type      = gaussian
response_max_value      = 30.0
response_min_value      = -30.0
response_mutate_power   = 0.0
response_mutate_rate    = 0.0
response_replace_rate   = 0.0

# === Pesi ===
# I pesi delle connessioni sono il "cervello" della rete
weight_init_mean        = 0.0
weight_init_stdev       = 1.0
weight_init_type        = gaussian
weight_max_value        = 30.0
weight_min_value        = -30.0

# Mutazioni dei pesi: bilanciate per esplorazione stabile
weight_mutate_power     = 0.4
weight_mutate_rate      = 0.8
weight_replace_rate     = 0.1

[DefaultSpeciesSet]
# Soglia di compatibilitÃ  per formare nuove specie
# PIÃ™ BASSO = piÃ¹ specie = piÃ¹ diversitÃ  = protezione innovazioni
# PIÃ™ ALTO = meno specie = convergenza piÃ¹ rapida
compatibility_threshold = 2.5

[DefaultStagnation]
# Fitness di riferimento per valutare stagnazione
species_fitness_func = max

# Generazioni senza miglioramento prima di eliminare una specie
# Pac-Man Ã¨ complesso: dai tempo alle strategie di maturare
max_stagnation       = 15

# Numero di migliori individui di ogni specie che passano invariati
# Preserva soluzioni buone trovate
species_elitism      = 3

[DefaultReproduction]
# Migliori individui globali che passano alla generazione successiva
# AUMENTATO per preservare le migliori soluzioni trovate
elitism            = 4

# Solo il top 25% di ogni specie si riproduce
# PiÃ¹ alto = piÃ¹ diversitÃ , meno pressione selettiva
survival_threshold = 0.25

# Dimensione minima per una specie
min_species_size   = 2


# =============================================================================
# ğŸ“Š GUIDA AL TUNING
# =============================================================================
#
# ğŸ”´ SE FITNESS RIMANE BLOCCATA A 0 PER >20 GENERAZIONI:
#    - Verifica che la fitness function non sia troppo severa
#    - Aumenta survival_threshold a 0.3
#    - Aumenta num_hidden a 8-10
#    - Abilita curriculum learning nel .py
#
# ğŸŸ¡ SE FITNESS CRESCE MA POI SI BLOCCA:
#    - Aumenta pop_size a 250-300
#    - Aumenta max_stagnation a 20
#    - Aumenta conn_add_prob a 0.5
#    - Aumenta node_add_prob a 0.3
#
# ğŸŸ¢ SE FITNESS OSCILLA TROPPO:
#    - Riduci weight_mutate_power a 0.3
#    - Riduci bias_mutate_power a 0.4
#    - Aumenta elitism a 5-6
#
# ğŸ”µ SE TROPPE SPECIE (>20):
#    - Aumenta compatibility_threshold a 3.0-3.5
#
# ğŸŸ£ SE POCHE SPECIE (<3):
#    - Abbassa compatibility_threshold a 2.0
#
# ğŸŸ  SE CONVERGE TROPPO RAPIDAMENTE (tutti genomi uguali):
#    - Aumenta weight_mutate_rate a 0.9
#    - Aumenta conn_add_prob a 0.5
#    - Abbassa compatibility_threshold a 2.0
#
# =============================================================================
# ğŸ“ˆ STRATEGIE PROGRESSIVE
# =============================================================================
#
# FASE 1 (Gen 0-30): Esplorazione iniziale
#    - Obiettivo: trovare strategie base di sopravvivenza
#    - Config corrente va bene
#
# FASE 2 (Gen 31-60): Raffinamento
#    - Se fitness > 100: abbassa weight_mutate_power a 0.3 (piÃ¹ conservativo)
#    - Se fitness < 50: aumenta node_add_prob a 0.3 (piÃ¹ complessitÃ )
#
# FASE 3 (Gen 61+): Ottimizzazione
#    - Se fitness > 500: aumenta elitism a 6 (preserva soluzioni ottime)
#    - Se fitness < 200: considera restart con piÃ¹ diversitÃ 
#
# =============================================================================